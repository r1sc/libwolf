include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

mod audiot;
mod imf;
mod vswap;

use cpal::{
    traits::{DeviceTrait, HostTrait, StreamTrait},
    Stream,
};
use minifb::{Key, Window, WindowOptions};
use std::{env::args, fs::File, io::BufReader, time::Duration};
use vswap::VSWAPArchive;

const GAMEPAL: [u8; 768] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x00, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x2A,
    0x00, 0x2A, 0x2A, 0x15, 0x00, 0x2A, 0x2A, 0x2A, 0x15, 0x15, 0x15, 0x15, 0x15, 0x3F, 0x15, 0x3F,
    0x15, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x15, 0x3F, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x3F, 0x3F, 0x3F,
    0x3B, 0x3B, 0x3B, 0x37, 0x37, 0x37, 0x34, 0x34, 0x34, 0x30, 0x30, 0x30, 0x2D, 0x2D, 0x2D, 0x2A,
    0x2A, 0x2A, 0x26, 0x26, 0x26, 0x23, 0x23, 0x23, 0x1F, 0x1F, 0x1F, 0x1C, 0x1C, 0x1C, 0x19, 0x19,
    0x19, 0x15, 0x15, 0x15, 0x12, 0x12, 0x12, 0x0E, 0x0E, 0x0E, 0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x08,
    0x3F, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x38, 0x00, 0x00, 0x35, 0x00, 0x00, 0x32, 0x00, 0x00, 0x2F,
    0x00, 0x00, 0x2C, 0x00, 0x00, 0x29, 0x00, 0x00, 0x26, 0x00, 0x00, 0x22, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x1C, 0x00, 0x00, 0x19, 0x00, 0x00, 0x16, 0x00, 0x00, 0x13, 0x00, 0x00, 0x10, 0x00, 0x00,
    0x3F, 0x36, 0x36, 0x3F, 0x2E, 0x2E, 0x3F, 0x27, 0x27, 0x3F, 0x1F, 0x1F, 0x3F, 0x17, 0x17, 0x3F,
    0x10, 0x10, 0x3F, 0x08, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x2A, 0x17, 0x3F, 0x26, 0x10, 0x3F, 0x22,
    0x08, 0x3F, 0x1E, 0x00, 0x39, 0x1B, 0x00, 0x33, 0x18, 0x00, 0x2D, 0x15, 0x00, 0x27, 0x13, 0x00,
    0x3F, 0x3F, 0x36, 0x3F, 0x3F, 0x2E, 0x3F, 0x3F, 0x27, 0x3F, 0x3F, 0x1F, 0x3F, 0x3E, 0x17, 0x3F,
    0x3D, 0x10, 0x3F, 0x3D, 0x08, 0x3F, 0x3D, 0x00, 0x39, 0x36, 0x00, 0x33, 0x31, 0x00, 0x2D, 0x2B,
    0x00, 0x27, 0x27, 0x00, 0x21, 0x21, 0x00, 0x1C, 0x1B, 0x00, 0x16, 0x15, 0x00, 0x10, 0x10, 0x00,
    0x34, 0x3F, 0x17, 0x31, 0x3F, 0x10, 0x2D, 0x3F, 0x08, 0x28, 0x3F, 0x00, 0x24, 0x39, 0x00, 0x20,
    0x33, 0x00, 0x1D, 0x2D, 0x00, 0x18, 0x27, 0x00, 0x36, 0x3F, 0x36, 0x2F, 0x3F, 0x2E, 0x27, 0x3F,
    0x27, 0x20, 0x3F, 0x1F, 0x18, 0x3F, 0x17, 0x10, 0x3F, 0x10, 0x08, 0x3F, 0x08, 0x00, 0x3F, 0x00,
    0x00, 0x3F, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x38, 0x00, 0x00, 0x35, 0x00, 0x01, 0x32, 0x00, 0x01,
    0x2F, 0x00, 0x01, 0x2C, 0x00, 0x01, 0x29, 0x00, 0x01, 0x26, 0x00, 0x01, 0x22, 0x00, 0x01, 0x1F,
    0x00, 0x01, 0x1C, 0x00, 0x01, 0x19, 0x00, 0x01, 0x16, 0x00, 0x01, 0x13, 0x00, 0x01, 0x10, 0x00,
    0x36, 0x3F, 0x3F, 0x2E, 0x3F, 0x3F, 0x27, 0x3F, 0x3F, 0x1F, 0x3F, 0x3E, 0x17, 0x3F, 0x3F, 0x10,
    0x3F, 0x3F, 0x08, 0x3F, 0x3F, 0x00, 0x3F, 0x3F, 0x00, 0x39, 0x39, 0x00, 0x33, 0x33, 0x00, 0x2D,
    0x2D, 0x00, 0x27, 0x27, 0x00, 0x21, 0x21, 0x00, 0x1C, 0x1C, 0x00, 0x16, 0x16, 0x00, 0x10, 0x10,
    0x17, 0x2F, 0x3F, 0x10, 0x2C, 0x3F, 0x08, 0x2A, 0x3F, 0x00, 0x27, 0x3F, 0x00, 0x23, 0x39, 0x00,
    0x1F, 0x33, 0x00, 0x1B, 0x2D, 0x00, 0x17, 0x27, 0x36, 0x36, 0x3F, 0x2E, 0x2F, 0x3F, 0x27, 0x27,
    0x3F, 0x1F, 0x20, 0x3F, 0x17, 0x18, 0x3F, 0x10, 0x10, 0x3F, 0x08, 0x09, 0x3F, 0x00, 0x01, 0x3F,
    0x00, 0x00, 0x3F, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x38, 0x00, 0x00, 0x35, 0x00, 0x00, 0x32, 0x00,
    0x00, 0x2F, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x29, 0x00, 0x00, 0x26, 0x00, 0x00, 0x22, 0x00, 0x00,
    0x1F, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x19, 0x00, 0x00, 0x16, 0x00, 0x00, 0x13, 0x00, 0x00, 0x10,
    0x0A, 0x0A, 0x0A, 0x3F, 0x38, 0x0D, 0x3F, 0x35, 0x09, 0x3F, 0x33, 0x06, 0x3F, 0x30, 0x02, 0x3F,
    0x2D, 0x00, 0x2D, 0x08, 0x3F, 0x2A, 0x00, 0x3F, 0x26, 0x00, 0x39, 0x20, 0x00, 0x33, 0x1D, 0x00,
    0x2D, 0x18, 0x00, 0x27, 0x14, 0x00, 0x21, 0x11, 0x00, 0x1C, 0x0D, 0x00, 0x16, 0x0A, 0x00, 0x10,
    0x3F, 0x36, 0x3F, 0x3F, 0x2E, 0x3F, 0x3F, 0x27, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x17, 0x3F, 0x3F,
    0x10, 0x3F, 0x3F, 0x08, 0x3F, 0x3F, 0x00, 0x3F, 0x38, 0x00, 0x39, 0x32, 0x00, 0x33, 0x2D, 0x00,
    0x2D, 0x27, 0x00, 0x27, 0x21, 0x00, 0x21, 0x1B, 0x00, 0x1C, 0x16, 0x00, 0x16, 0x10, 0x00, 0x10,
    0x3F, 0x3A, 0x37, 0x3F, 0x38, 0x34, 0x3F, 0x36, 0x31, 0x3F, 0x35, 0x2F, 0x3F, 0x33, 0x2C, 0x3F,
    0x31, 0x29, 0x3F, 0x2F, 0x27, 0x3F, 0x2E, 0x24, 0x3F, 0x2C, 0x20, 0x3F, 0x29, 0x1C, 0x3F, 0x27,
    0x18, 0x3C, 0x25, 0x17, 0x3A, 0x23, 0x16, 0x37, 0x22, 0x15, 0x34, 0x20, 0x14, 0x32, 0x1F, 0x13,
    0x2F, 0x1E, 0x12, 0x2D, 0x1C, 0x11, 0x2A, 0x1A, 0x10, 0x28, 0x19, 0x0F, 0x27, 0x18, 0x0E, 0x24,
    0x17, 0x0D, 0x22, 0x16, 0x0C, 0x20, 0x14, 0x0B, 0x1D, 0x13, 0x0A, 0x1B, 0x12, 0x09, 0x17, 0x10,
    0x08, 0x15, 0x0F, 0x07, 0x12, 0x0E, 0x06, 0x10, 0x0C, 0x06, 0x0E, 0x0B, 0x05, 0x0A, 0x08, 0x03,
    0x18, 0x00, 0x19, 0x00, 0x19, 0x19, 0x00, 0x18, 0x18, 0x00, 0x00, 0x07, 0x00, 0x00, 0x0B, 0x0C,
    0x09, 0x04, 0x12, 0x00, 0x12, 0x14, 0x00, 0x14, 0x00, 0x00, 0x0D, 0x07, 0x07, 0x07, 0x13, 0x13,
    0x13, 0x17, 0x17, 0x17, 0x10, 0x10, 0x10, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x36, 0x3D, 0x3D,
    0x2E, 0x3A, 0x3A, 0x27, 0x37, 0x37, 0x1D, 0x32, 0x32, 0x12, 0x30, 0x30, 0x08, 0x2D, 0x2D, 0x08,
    0x2C, 0x2C, 0x00, 0x29, 0x29, 0x00, 0x26, 0x26, 0x00, 0x23, 0x23, 0x00, 0x21, 0x21, 0x00, 0x1F,
    0x1F, 0x00, 0x1E, 0x1E, 0x00, 0x1D, 0x1D, 0x00, 0x1C, 0x1C, 0x00, 0x1B, 0x1B, 0x26, 0x00, 0x22,
];

fn start_music(wolf_base_path: &str, music_number: usize) -> Stream {
    let host = cpal::default_host();
    let device = host
        .default_output_device()
        .expect("no output device available");

    let mut supported_configs_range = device
        .supported_output_configs()
        .expect("error while querying configs");

    let supported_config = supported_configs_range
        .next()
        .expect("no supported config?!")
        .with_max_sample_rate();

    let config = supported_config.config();
    println!("Using output config: {:?}", supported_config);

    let sample_rate = supported_config.sample_rate().0;

    let mut imf = imf::Imf::new(wolf_base_path, music_number, sample_rate).unwrap();

    let stream = match device.build_output_stream(
        &config,
        move |data: &mut [i16], _: &cpal::OutputCallbackInfo| match imf
            .fill_audio_buffer(data, config.channels as usize)
        {
            Ok(_) => {}
            Err(e) => panic!("Error while filling audio buffer: {}", e),
        },
        move |_err| {
            // react to errors here.
        },
        None, // None=blocking, Some(Duration)=timeout
    ) {
        Ok(stream) => stream,
        Err(err) => panic!("An error occurred: {}", err),
    };

    stream.play().unwrap();

    stream
}

fn main() {
    let music_number = args()
        .nth(1)
        .expect("usage: wolf_audio <music number>")
        .parse::<usize>()
        .expect("<music number> must be a number");

    let mut palette_u32 = vec![0; 256];

    let brightness = 2;
    for i in 0..256 {
        let r = GAMEPAL[i * 3] as u32;
        let g = GAMEPAL[i * 3 + 1] as u32;
        let b = GAMEPAL[i * 3 + 2] as u32;

        palette_u32[i] = (r << brightness << 16) | (g << brightness << 8) | b << brightness;
    }

    let wolf_base_path = r"c:\classic\wolf3d";

    let mut reader = BufReader::new(File::open(format!("{}/vswap.wl6", wolf_base_path)).unwrap());
    let vswap = VSWAPArchive::open(&mut reader).unwrap();

    let mut output_buffer: Vec<u32> = vec![0; 64 * 64];
    let mut current_sprite = 0;

    vswap.rasterize_wall(18, &palette_u32, &mut output_buffer);
    vswap.rasterize_sprite(54, &palette_u32, &mut output_buffer);

    let scale = 10;
    let mut window = Window::new(
        "Test - ESC to exit",
        64 * scale,
        64 * scale,
        WindowOptions::default(),
    )
    .unwrap_or_else(|e| {
        panic!("{}", e);
    });

    window.set_target_fps(30);

    // Give cpal it's own thread. Otherwise local thread sleeps can cause the buffers to go out of sync... sigh
    std::thread::spawn(move || {     
        // This variable must be here otherwise the stream will go out of scope and stop itself
        let _a = start_music(wolf_base_path, music_number);
        std::thread::park();
    });

    while window.is_open() {
        if window.is_key_pressed(Key::Right, minifb::KeyRepeat::Yes)
            && current_sprite < vswap.sprite_chunks.len() - 1
        {
            current_sprite += 1;
            output_buffer.fill(0);
            vswap.rasterize_sprite(current_sprite, &palette_u32, &mut output_buffer);
        } else if window.is_key_pressed(Key::Left, minifb::KeyRepeat::Yes) && current_sprite > 0 {
            current_sprite -= 1;
            output_buffer.fill(0);
            vswap.rasterize_sprite(current_sprite, &palette_u32, &mut output_buffer);
        }

        window.set_title(&format!("Sprite: {}", current_sprite));

        window.update_with_buffer(&output_buffer, 64, 64).unwrap();
    }
}
